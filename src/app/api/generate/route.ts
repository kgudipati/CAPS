import { NextResponse } from 'next/server';
import { ProjectInputState, FileData } from '@/types';
import { readTemplateFile, createZipArchive } from '@/lib/files';
// import { generateContent } from '@/lib/ai'; // TODO: Implement AI generation logic
// import { constructPrompts } from '@/lib/prompts'; // TODO: Implement prompt construction

const STATIC_RULES = [
  'general-best-practices.mdc',
  'logging-and-debugging.mdc',
  'tdd-and-testing.mdc',
  'github-commit-discipline.mdc',
  'scalability.mdc',
  'mcp-tools.mdc',
];

export async function POST(request: Request) {
  console.log('Received POST request to /api/generate');
  let requestBody;
  try {
    requestBody = await request.json() as Omit<ProjectInputState, 'isLoading' | 'error' | 'apiKey'>;
    // TODO: Add more robust validation (e.g., using Zod)
    console.log('Request body parsed:', requestBody);
  } catch (error) {
    console.error('Error parsing request body:', error);
    return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
  }

  const apiKey = process.env.AI_API_KEY;
  if (!apiKey) {
    console.error('AI_API_KEY environment variable is not set.');
    return NextResponse.json({ error: 'Server configuration error: AI API key missing.' }, { status: 500 });
  }

  try {
    const filesToZip: FileData[] = [];

    // 1. Add static rules
    console.log('Reading static rule files...');
    for (const ruleFile of STATIC_RULES) {
      const content = await readTemplateFile(`rules/${ruleFile}`);
      filesToZip.push({ path: `.cursor/rules/${ruleFile}`, content });
    }
    console.log('Static rules added.');

    // --- TODO: AI Generation Steps --- 
    console.log('Simulating AI generation...');
    // const prompts = constructPrompts(requestBody);
    let generatedProjectRule = `# Project Specific Rules (Generated by AI)

Rule 1: ... based on description ...
Rule 2: ... based on tech stack ...`;
    let generatedPrd = `# PRD (Generated by AI)

Based on user input...`;
    let generatedChecklist = `# Checklist (Generated by AI)

- [ ] Task 1: Setup...
- [ ] Task 2: Implement feature X...`;
    // Simulate API calls for each required item
    // generatedProjectRule = await generateContent(prompts.projectRule, apiKey);
    // if (requestBody.generationOptions.specs.prd) { generatedPrd = await generateContent(prompts.prd, apiKey); }
    // ... and so on for other specs and checklist
    await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate delay
    console.log('AI generation simulation complete.');
    // --- End AI Generation Simulation --- 

    // 2. Add generated files (based on selections and simulated AI output)
    if (requestBody.generationOptions.rules) {
        filesToZip.push({ path: '.cursor/rules/project-specific-rules.mdc', content: generatedProjectRule });
    }
    if (requestBody.generationOptions.specs.prd) {
        filesToZip.push({ path: 'docs/prd.md', content: generatedPrd });
    }
    // Add other selected specs similarly...
     if (requestBody.generationOptions.specs.tps) { filesToZip.push({ path: 'docs/tps.md', content: '# TPS (Generated)' }); }
     if (requestBody.generationOptions.specs.uiUx) { filesToZip.push({ path: 'docs/ui-ux-spec.md', content: '# UI/UX Spec (Generated)' }); }
     if (requestBody.generationOptions.specs.technical) { filesToZip.push({ path: 'docs/technical-spec.md', content: '# Technical Spec (Generated)' }); }
     if (requestBody.generationOptions.specs.data) { filesToZip.push({ path: 'docs/data-spec.md', content: '# Data Spec (Generated)' }); }
     if (requestBody.generationOptions.specs.integration) { filesToZip.push({ path: 'docs/integration-spec.md', content: '# Integration Spec (Generated)' }); }

    if (requestBody.generationOptions.checklist) {
      filesToZip.push({ path: 'checklist.md', content: generatedChecklist });
    }
    console.log('Generated files added to list.');

    // 3. Create ZIP archive
    console.log('Creating ZIP archive...');
    const zipBuffer = await createZipArchive(filesToZip);
    console.log('ZIP archive created.');

    // 4. Return ZIP file
    return new NextResponse(zipBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': `attachment; filename="cursor-starter-kit-${Date.now()}.zip"`,
      },
    });

  } catch (error) {
    console.error('Error during starter kit generation:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return NextResponse.json({ error: `Failed to generate starter kit: ${errorMessage}` }, { status: 500 });
  }
} 